
import { useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { CalendarEvent } from '@/types/calendar';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/context/auth';

interface CalendarFilter {
  startDate?: Date;
  endDate?: Date;
  type?: string[];
  search?: string;
  includeTaskEvents?: boolean;
}

export const useCalendar = (filter?: CalendarFilter) => {
  const queryClient = useQueryClient();
  const { user } = useAuth();
  
  // Fetch events from Supabase with optional date range filtering
  const {
    data: events,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['calendar', filter, user?.id],
    queryFn: async () => {
      if (!user) return [];

      let query = supabase
        .from('calendar_events')
        .select(`
          *,
          source_task_id,
          auto_generated
        `)
        .eq('user_id', user.id)
        .order('start_date', { ascending: true });

      // Apply date range filter
      if (filter?.startDate) {
        query = query.gte('start_date', filter.startDate.toISOString());
      }
      if (filter?.endDate) {
        query = query.lte('start_date', filter.endDate.toISOString());
      }

      // Apply type filter
      if (filter?.type && filter.type.length > 0) {
        query = query.in('type', filter.type);
      }

      // Apply search filter
      if (filter?.search) {
        query = query.or(`title.ilike.%${filter.search}%,description.ilike.%${filter.search}%,location.ilike.%${filter.search}%`);
      }

      const { data, error } = await query;
      
      if (error) {
        console.error('Error fetching calendar events:', error);
        throw error;
      }

      // Transform database format to CalendarEvent format
      return data.map(event => ({
        id: event.id,
        title: event.title,
        description: event.description || '',
        startDate: event.start_date,
        endDate: event.end_date || undefined,
        allDay: event.all_day,
        location: event.location || undefined,
        type: event.type as "event" | "task" | "reminder",
        recurring: event.recurring,
        recurringType: event.recurring_type as "daily" | "weekly" | "biweekly" | "monthly" | "yearly" | "none" | undefined,
        user_id: event.user_id,
        created_at: event.created_at,
        updated_at: event.updated_at,
        content: {
          ...(event.content || {}),
          sourceTaskId: event.source_task_id,
          autoGenerated: event.auto_generated
        }
      })) as CalendarEvent[];
    },
    enabled: !!user,
  });

  // Create new event
  const createEventMutation = useMutation({
    mutationFn: async (newEvent: Omit<CalendarEvent, 'id'>) => {
      if (!user) {
        throw new Error('User must be authenticated to create events');
      }

      const eventData = {
        user_id: user.id,
        title: newEvent.title,
        description: newEvent.description || null,
        start_date: newEvent.startDate,
        end_date: newEvent.endDate || null,
        all_day: newEvent.allDay,
        location: newEvent.location || null,
        type: newEvent.type,
        recurring: newEvent.recurring,
        recurring_type: newEvent.recurringType || null,
        content: newEvent.content || {},
        auto_generated: false
      };
      
      const { data, error } = await supabase
        .from('calendar_events')
        .insert([eventData])
        .select()
        .single();
      
      if (error) {
        console.error('Error creating calendar event:', error);
        throw error;
      }
      
      console.log("Created new event:", data);
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
    },
  });

  // Update event
  const updateEventMutation = useMutation({
    mutationFn: async (updatedEvent: CalendarEvent) => {
      if (!user) {
        throw new Error('User must be authenticated to update events');
      }

      const eventData = {
        title: updatedEvent.title,
        description: updatedEvent.description || null,
        start_date: updatedEvent.startDate,
        end_date: updatedEvent.endDate || null,
        all_day: updatedEvent.allDay,
        location: updatedEvent.location || null,
        type: updatedEvent.type,
        recurring: updatedEvent.recurring,
        recurring_type: updatedEvent.recurringType || null,
        content: updatedEvent.content || {}
      };
      
      const { data, error } = await supabase
        .from('calendar_events')
        .update(eventData)
        .eq('id', updatedEvent.id)
        .eq('user_id', user.id)
        .select()
        .single();
      
      if (error) {
        console.error('Error updating calendar event:', error);
        throw error;
      }
      
      console.log("Updated event:", data);
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
    },
  });

  // Delete event
  const deleteEventMutation = useMutation({
    mutationFn: async (eventId: string) => {
      if (!user) {
        throw new Error('User must be authenticated to delete events');
      }
      
      const { error } = await supabase
        .from('calendar_events')
        .delete()
        .eq('id', eventId)
        .eq('user_id', user.id);
      
      if (error) {
        console.error('Error deleting calendar event:', error);
        throw error;
      }
      
      console.log("Deleted event:", eventId);
      return eventId;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
    },
  });

  return {
    events,
    isLoading,
    error,
    createEvent: createEventMutation.mutate,
    updateEvent: updateEventMutation.mutate,
    deleteEvent: deleteEventMutation.mutate,
  };
};
